#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "${ROOT_DIR}"

STATE_FILE=".mounts.state"
OVERRIDE_FILE="docker-compose.override.yml"
HEADER="# generated by scripts/add-mount.sh"

if [[ ! -f ".env" ]]; then
  echo "Missing .env in ${ROOT_DIR}. Run: cp .env.example .env"
  exit 1
fi

if [[ ! -f "docker-compose.yml" ]]; then
  echo "Missing docker-compose.yml in ${ROOT_DIR}"
  exit 1
fi

run_root() {
  if [[ "${EUID}" -eq 0 ]]; then
    "$@"
  else
    sudo "$@"
  fi
}

env_value() {
  local key="$1"
  awk -F= -v key="$key" '$1==key{print substr($0, index($0,"=")+1); exit}' .env
}

PUID_VALUE="${PUID:-$(env_value PUID)}"
PGID_VALUE="${PGID:-$(env_value PGID)}"
PUID_VALUE="${PUID_VALUE:-1000}"
PGID_VALUE="${PGID_VALUE:-1000}"

if [[ -f "${OVERRIDE_FILE}" && ! -f "${STATE_FILE}" ]]; then
  if ! grep -qF "${HEADER}" "${OVERRIDE_FILE}"; then
    echo "Found existing ${OVERRIDE_FILE} not managed by this script."
    echo "Please migrate manually or move it away before using this script."
    exit 1
  fi
fi

mapfile -t SERVICES < <(run_root docker compose config --services)
if [[ "${#SERVICES[@]}" -eq 0 ]]; then
  echo "No services found in docker-compose.yml"
  exit 1
fi

echo "Available services:"
for i in "${!SERVICES[@]}"; do
  printf "  %d) %s\n" "$((i + 1))" "${SERVICES[i]}"
done

read -r -p "Select service number: " PICK
if ! [[ "${PICK}" =~ ^[0-9]+$ ]] || (( PICK < 1 || PICK > ${#SERVICES[@]} )); then
  echo "Invalid selection."
  exit 1
fi
SERVICE="${SERVICES[PICK-1]}"

read -r -p "Host directory (absolute path): " HOST_PATH
read -r -p "Container directory (absolute path): " CONTAINER_PATH

if [[ -z "${HOST_PATH}" || -z "${CONTAINER_PATH}" ]]; then
  echo "Path cannot be empty."
  exit 1
fi
if [[ "${HOST_PATH}" != /* || "${CONTAINER_PATH}" != /* ]]; then
  echo "Both paths must be absolute."
  exit 1
fi
if [[ "${HOST_PATH}" == *:* || "${CONTAINER_PATH}" == *:* ]]; then
  echo "Path cannot contain ':'."
  exit 1
fi

case "${SERVICE}" in
  openlist)
    if [[ "${CONTAINER_PATH}" == "/opt/openlist/data" || "${CONTAINER_PATH}" == /opt/openlist/data/* ]]; then
      echo "Do not mount extra paths under /opt/openlist/data; it may break OpenList startup checks."
      exit 1
    fi
    ;;
  jellyfin)
    if [[ "${CONTAINER_PATH}" == "/config" || "${CONTAINER_PATH}" == "/cache" ]]; then
      echo "Container path ${CONTAINER_PATH} is reserved for Jellyfin."
      exit 1
    fi
    ;;
  qbittorrent)
    if [[ "${CONTAINER_PATH}" == "/config" ]]; then
      echo "Container path /config is reserved for qBittorrent."
      exit 1
    fi
    ;;
  caddy)
    if [[ "${CONTAINER_PATH}" == "/data" || "${CONTAINER_PATH}" == "/config" ]]; then
      echo "Container path ${CONTAINER_PATH} is reserved for Caddy."
      exit 1
    fi
    ;;
esac

DEFAULT_MODE="rw"
if [[ "${SERVICE}" == "jellyfin" || "${SERVICE}" == "caddy" ]]; then
  DEFAULT_MODE="ro"
fi
read -r -p "Mount mode [rw/ro] (default: ${DEFAULT_MODE}): " MODE
MODE="${MODE:-${DEFAULT_MODE}}"
if [[ "${MODE}" != "rw" && "${MODE}" != "ro" ]]; then
  echo "Mode must be rw or ro."
  exit 1
fi

if [[ -f "${STATE_FILE}" ]] && awk -F'|' -v s="${SERVICE}" -v c="${CONTAINER_PATH}" '$1==s && $3==c {found=1} END{exit found?0:1}' "${STATE_FILE}"; then
  echo "A mapping for ${SERVICE} -> ${CONTAINER_PATH} already exists."
  read -r -p "Replace it? [y/N]: " REPLACE
  REPLACE="${REPLACE:-N}"
  if [[ "${REPLACE}" != "y" && "${REPLACE}" != "Y" ]]; then
    echo "Cancelled."
    exit 0
  fi
  awk -F'|' -v s="${SERVICE}" -v c="${CONTAINER_PATH}" '!( $1==s && $3==c )' "${STATE_FILE}" > "${STATE_FILE}.tmp"
  mv "${STATE_FILE}.tmp" "${STATE_FILE}"
fi

run_root mkdir -p "${HOST_PATH}"
run_root chown "${PUID_VALUE}:${PGID_VALUE}" "${HOST_PATH}"
if [[ "${MODE}" == "rw" ]]; then
  run_root chmod 775 "${HOST_PATH}"
else
  run_root chmod 755 "${HOST_PATH}"
fi

echo "Permission default applied to directory only."
read -r -p "Apply recursive chown/chmod to all subfiles? [y/N]: " RECURSIVE
RECURSIVE="${RECURSIVE:-N}"
if [[ "${RECURSIVE}" == "y" || "${RECURSIVE}" == "Y" ]]; then
  run_root chown -R "${PUID_VALUE}:${PGID_VALUE}" "${HOST_PATH}"
  if [[ "${MODE}" == "rw" ]]; then
    run_root chmod -R u+rwX,g+rwX "${HOST_PATH}"
  else
    run_root chmod -R u+rwX,g+rX "${HOST_PATH}"
  fi
fi

touch "${STATE_FILE}"
if ! grep -Fqx "${SERVICE}|${HOST_PATH}|${CONTAINER_PATH}|${MODE}" "${STATE_FILE}"; then
  printf "%s|%s|%s|%s\n" "${SERVICE}" "${HOST_PATH}" "${CONTAINER_PATH}" "${MODE}" >> "${STATE_FILE}"
fi

if [[ -f "${OVERRIDE_FILE}" ]]; then
  cp "${OVERRIDE_FILE}" "${OVERRIDE_FILE}.bak.$(date +%Y%m%d%H%M%S)"
fi

{
  echo "${HEADER}"
  echo "services:"
  awk -F'|' 'NF {print $1}' "${STATE_FILE}" | uniq | while read -r svc; do
    [[ -z "${svc}" ]] && continue
    echo "  ${svc}:"
    echo "    volumes:"
    awk -F'|' -v s="${svc}" '$1==s {printf "      - %s:%s:%s\n", $2, $3, $4}' "${STATE_FILE}"
  done
} > "${OVERRIDE_FILE}"

run_root docker compose config >/dev/null
run_root docker compose up -d --force-recreate "${SERVICE}"

echo
echo "Mount added successfully."
echo "Service: ${SERVICE}"
echo "Mapping: ${HOST_PATH}:${CONTAINER_PATH}:${MODE}"
echo "Updated file: ${OVERRIDE_FILE}"
echo
echo "Note: bind mounts do not delete host data, but if container path already has built-in files, they will be hidden by the mount."
