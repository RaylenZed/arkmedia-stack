#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
STACKS=(gateway openlist emby qbittorrent dify watchtower)

run_root() {
  if [[ "${EUID}" -eq 0 ]]; then
    "$@"
  else
    sudo "$@"
  fi
}

env_file_for_stack() {
  local stack="$1"
  local env_file="${ROOT_DIR}/${stack}/.env"
  if [[ -f "${env_file}" ]]; then
    echo "${env_file}"
    return
  fi
  echo ""
}

pick_env_value() {
  local env_file="$1"
  local key="$2"
  awk -F= -v key="${key}" '$1==key {print substr($0, index($0,"=")+1); exit}' "${env_file}"
}

echo "Available stacks:"
for i in "${!STACKS[@]}"; do
  printf "  %d) %s\n" "$((i + 1))" "${STACKS[i]}"
done

read -r -p "Select stack number: " STACK_PICK
if ! [[ "${STACK_PICK}" =~ ^[0-9]+$ ]] || (( STACK_PICK < 1 || STACK_PICK > ${#STACKS[@]} )); then
  echo "Invalid selection."
  exit 1
fi
STACK="${STACKS[STACK_PICK-1]}"
ENV_FILE="$(env_file_for_stack "${STACK}")"
if [[ -z "${ENV_FILE}" ]]; then
  echo "Missing ${ROOT_DIR}/${STACK}/.env"
  echo "Run: cp ${ROOT_DIR}/${STACK}/.env.example ${ROOT_DIR}/${STACK}/.env"
  exit 1
fi

COMPOSE_FILE="${ROOT_DIR}/${STACK}/docker-compose.yml"
OVERRIDE_FILE="${ROOT_DIR}/${STACK}/docker-compose.override.yml"
STATE_FILE="${ROOT_DIR}/${STACK}/.mounts.state"
HEADER="# generated by scripts/add-mount.sh"

mapfile -t SERVICES < <(run_root docker compose --env-file "${ENV_FILE}" -f "${COMPOSE_FILE}" config --services)
if [[ "${#SERVICES[@]}" -eq 0 ]]; then
  echo "No services found in ${COMPOSE_FILE}"
  exit 1
fi

echo "Available services in ${STACK}:"
for i in "${!SERVICES[@]}"; do
  printf "  %d) %s\n" "$((i + 1))" "${SERVICES[i]}"
done

read -r -p "Select service number: " SERVICE_PICK
if ! [[ "${SERVICE_PICK}" =~ ^[0-9]+$ ]] || (( SERVICE_PICK < 1 || SERVICE_PICK > ${#SERVICES[@]} )); then
  echo "Invalid selection."
  exit 1
fi
SERVICE="${SERVICES[SERVICE_PICK-1]}"

read -r -p "Host directory (absolute path): " HOST_PATH
read -r -p "Container directory (absolute path): " CONTAINER_PATH

if [[ -z "${HOST_PATH}" || -z "${CONTAINER_PATH}" ]]; then
  echo "Path cannot be empty."
  exit 1
fi
if [[ "${HOST_PATH}" != /* || "${CONTAINER_PATH}" != /* ]]; then
  echo "Both paths must be absolute."
  exit 1
fi

case "${SERVICE}" in
  openlist)
    if [[ "${CONTAINER_PATH}" == "/opt/openlist/data" || "${CONTAINER_PATH}" == /opt/openlist/data/* ]]; then
      echo "Do not mount extra paths under /opt/openlist/data; it may break OpenList startup checks."
      exit 1
    fi
    ;;
  emby)
    if [[ "${CONTAINER_PATH}" == "/config" ]]; then
      echo "Container path ${CONTAINER_PATH} is reserved for Emby."
      exit 1
    fi
    ;;
  qbittorrent)
    if [[ "${CONTAINER_PATH}" == "/config" ]]; then
      echo "Container path ${CONTAINER_PATH} is reserved for qBittorrent."
      exit 1
    fi
    ;;
  caddy)
    if [[ "${CONTAINER_PATH}" == "/data" || "${CONTAINER_PATH}" == "/config" ]]; then
      echo "Container path ${CONTAINER_PATH} is reserved for Caddy."
      exit 1
    fi
    ;;
esac

DEFAULT_MODE="rw"
if [[ "${SERVICE}" == "emby" || "${SERVICE}" == "caddy" ]]; then
  DEFAULT_MODE="ro"
fi
read -r -p "Mount mode [rw/ro] (default: ${DEFAULT_MODE}): " MODE
MODE="${MODE:-${DEFAULT_MODE}}"
if [[ "${MODE}" != "rw" && "${MODE}" != "ro" ]]; then
  echo "Mode must be rw or ro."
  exit 1
fi

UID_VALUE="$(pick_env_value "${ENV_FILE}" PUID)"
GID_VALUE="$(pick_env_value "${ENV_FILE}" PGID)"

if [[ "${SERVICE}" == "openlist" ]]; then
  UID_VALUE="$(pick_env_value "${ENV_FILE}" OPENLIST_UID)"
  GID_VALUE="$(pick_env_value "${ENV_FILE}" OPENLIST_GID)"
fi

if [[ -z "${UID_VALUE}" || -z "${GID_VALUE}" ]]; then
  UID_VALUE=1000
  GID_VALUE=1000
fi

if [[ "${SERVICE}" == "caddy" || "${SERVICE}" == "watchtower" ]]; then
  UID_VALUE=0
  GID_VALUE=0
fi

run_root mkdir -p "${HOST_PATH}"
run_root chown "${UID_VALUE}:${GID_VALUE}" "${HOST_PATH}"
if [[ "${MODE}" == "rw" ]]; then
  run_root chmod 775 "${HOST_PATH}"
else
  run_root chmod 755 "${HOST_PATH}"
fi

touch "${STATE_FILE}"
if ! grep -Fqx "${SERVICE}|${HOST_PATH}|${CONTAINER_PATH}|${MODE}" "${STATE_FILE}"; then
  printf "%s|%s|%s|%s\n" "${SERVICE}" "${HOST_PATH}" "${CONTAINER_PATH}" "${MODE}" >> "${STATE_FILE}"
fi

{
  echo "${HEADER}"
  echo "services:"
  awk -F'|' 'NF {print $1}' "${STATE_FILE}" | uniq | while read -r svc; do
    [[ -z "${svc}" ]] && continue
    echo "  ${svc}:"
    echo "    volumes:"
    awk -F'|' -v s="${svc}" '$1==s {printf "      - %s:%s:%s\n", $2, $3, $4}' "${STATE_FILE}"
  done
} > "${OVERRIDE_FILE}"

run_root docker compose --env-file "${ENV_FILE}" -f "${COMPOSE_FILE}" -f "${OVERRIDE_FILE}" config >/dev/null
run_root docker compose --env-file "${ENV_FILE}" -f "${COMPOSE_FILE}" -f "${OVERRIDE_FILE}" up -d --force-recreate "${SERVICE}"

echo ""
echo "Mount added successfully."
echo "Stack: ${STACK}"
echo "Service: ${SERVICE}"
echo "Mapping: ${HOST_PATH}:${CONTAINER_PATH}:${MODE}"
echo "Updated file: ${OVERRIDE_FILE}"
